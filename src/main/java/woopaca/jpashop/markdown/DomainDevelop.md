# 회원 도메인 개발

## 회원 리포지토리 개발

- `@PersistenceContext` 애노테이션을 사용하면 스프링이 `EntityManager`를 만들어서 주입해 준다.
- `EntityManger`의 `persist()` 메서드는 영속성 컨텍스트에 엔티티를 넣는다. (나중에 transaction이 commit되는 시점에 DB에 `insert` 쿼리가 날라간다.)

## 회원 서비스 개발

- JPA의 모든 데이터 변경이나 로직들은 트랜젝션 안에서 수행되어야 한다.
- `@Transactional` 애노테이션은 스프링에서 제공하는 것과 자바에서 제공하는 것 두 가지가 있다. 스프링에서 제공하는 애노테이션이 기능도 더 많이 제공하고, 이미 스프링에 의존하는 로직이 많이 들어갔기 때문에 스프링에서 제공하는 애노테이션을 사용하는 것이 좋다. (클래스 레벨에 작성하면 public 메서드에 모두 적용)
- `@Transactional(readOnly = true)` → JPA가 조회하는 곳에서 성능을 최적화한다. (여러가지 이유)
  따라서 가급적이면 조회 로직에서는 해당 설정을 해주는 것이 좋다.

## 회원 기능 테스트

- 테스트에서 `@Transactional` 애노테이션은 기본적으로 롤백을 한다. service나 repository에서 사용하는 경우에는 롤백하지 않는다.
- JPA에서 같은 트랜잭션 안에서 PK 값이 같은 엔티티는 모두 하나의 영속성 컨텍스트에서 관리된다.
- 기본적으로 롤백이 되기 때문에 `insert`문이 없다. `@Rollback(value = false)`로 설정하면 트랜잭션이 커밋되며 `insert`문이 날아간다.
- 테스트에서 외부 DB를 사용하는 것은 편리하지 않다. 그래서 완전히 격리된 환경에서 자바 안에 DB를 만들어 띄우는 방법이 있다. → 메모리 DB 사용 (스프링 부트에서 제공)
- 테스트와 운영의 설정을 따로 해주는 것이 좋다.

### 메모리 DB 사용 방법

`test` 패키지 내에 `resources` 패키지를 생성한다.(테스트에서는 `test.resources`가 우선권을 가진다.) 내부에 `application.yml` 생성. `spring.datasource.url`에 In-Memory DB 설정

> Spring Boot에서는 위의 설정을 하지 않고 아무것도 작성하지 않아도 기본으로 메모리 모드로 동작한다.

# 상품 도메인 개발

## 상품 엔티티 개발

- 엔티티의 필드와 관련된 로직은 엔티티 안에 작성하는 것이 객체 지향적이고 좋은 구조

## 상품 리포지토리 개발

- `EntityManager`의 `merge()`는 update와 유사하다. 자세한 내용은 뒤에서 배운다.

## 상품 서비스 개발

- 만약 비즈니스 계층의 메서드가 단순히 리포지토리의 메서드를 호출하여 반환하는, 단순히 위임하는 역할이라면 컨트롤러에서 직접 리포지토리를 주입받아 메서드를 호출하는 것도 고민해 볼 필요가 있다.

# 주문 도메인 개발

## 주문 • 주문 상품 엔티티 개발

- 생성 메서드 → 엔티티 내부에 엔티티를 생성하는 로직을 작성한다.
- 정적 팩토리 메서드

## 주문 서비스 개발

- 코드를 제약하는 스타일로 작성하는 것이 좋은 설계와 유지보수 형태로 이끌어 갈 수 있다.
- JPA는 엔티티의 데이터가 변경되면 알아서 변경된 데이터들을 (더티 체킹, 변경 내역 감지) DB에 업데이트
- 엔티티에 있는 핵심 비즈니스 로직을 서비스에서 호출하는 방식을 ‘도메인 모델 패턴’이라고 한다. → 서비스 계층은 단순히 엔티티에 필요한 요청을 위임하는 역할을 한다. (반대는 트랜재션 스크립트 패턴)

## 주문 검색 기능 개발

**[ EntityManager의 메서드 ]**

- `setParameter(String name, Object value)` : 파라미터 설정
- `setMaxResult(int maxResult)` : 최대 조회 row 개수 설정
- `setFirstResult(int startPosition)` : `startPosition`부터 조회 시작

### JPA에서 동적 쿼리 해결

만약 파라미터가 없는 경우는 모든 row를 조회하고, 파라미터가 있다면 해당 파라미터를 `WHERE`절의 조건으로 설정해야 한다. 이렇게 동적 쿼리를 해결하는 것은 쉽지는 않다.

1. 직접 `if` 조건문을 사용해 JPQL 문자를 생성하고, if 조건문으로 `setParameter()`를 사용하는 매우 복잡한 방법
2. `Criteria`를 사용. 이것도 복잡한 방법
3. QueryDSL 사용. 매우 편리하다.

> QueryDSL은 자바에서 동적 쿼리를 작성하기 위한 라이브러리이다. SQL과 유사한 자바 문법을 사용하여 쿼리를 작성하며, 코드 자동완성을 지원하여 쉬운 쿼리 작성이 가능하다. 또한, 컴파일 시점에서 쿼리 오류를 체크할 수 있어 안정적인 쿼리 작성이 가능하다.
>